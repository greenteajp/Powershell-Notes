## LOGIN
xfreerdp /u:student /v:10.50.36.193 /dynamic-resolution +glyph-cache +clipboard


update-help -Force -ErrorAction SilentlyContinue
-ShowWindow for a "get-help/man 'cmdlet' " diplays a windows, usefull for ctrl-f

Day 1:
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

get-childitem -path C:\ -recurse -filter *.pf -name

#switch parameter: Boolean in nature. when used, the parameter is turned on
#otherwise its off by default
#-recurse

#positional parameters: 
#i.e '-path' , automatically added with get-childitem
#default, '-filter' filters on one thing at a time
#'-filter *.pf', parameter set


gci -Red C:\Windows\System32 -filt *.pf -na
get-childitem -recurse -filter *.pf C:\ -name
#can shorten -recurse to -rec -re; and -filter to -filt ; -name to -na


get-service -name power,dnscache
#get-service power,dnscache


get-command -verb get | measure
get-command -Noun *item | item | *item*
Get-Command *fire*
Get-Command get-*fire*
#Best use:: get-command *keyword* i.ie tcp,udp, item, etc

--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Alias:
$alias:man, etc...      echo=Write-Host
#alias stored in variable $alias

get-alias -definition get-childitem
#setting/deleting alias. Only last per session, need persistence
set-alias lmao explorer.exe
del alias:lmao

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Variables:
int
string
array


$number=61742
$number - 1   ##variable substitution
$var = gci C:\Windows

$nospaces="death"

$var1,$var2 = 25, 5   ###can create multiple variables in one line
$var1 = $var2 = $var 3 = 25 ##3 all three v ariables equal same value

get-variable var1 ### must omit the '$'       //### gci variable:  ##to get list of variables, or just get-variable

###Boolean
$true
$false

###Environmental Variables:
#variables that do not go away, global/system wide
$env:HomePath = $HOME    


### Need to know automatic variables!!!!!:

$args
Contains an array of values for undeclared parameters that are passed to a function, script, or script block. 
When you create a function, you can declare the parameters by using the param keyword or by adding a comma-separated list 
of parameters in parentheses after the function name.

$input
Contains an enumerator that enumerates all input that is passed to a function. 
The $input variable is available only to functions and script blocks (which are unnamed functions).

$_    ###same as $PSItem
Same as $PSItem. Contains the current object in the pipeline object. 
You can use this variable in commands that perform an action on every object or on selected objects in a pipeline.

$PROFILE   ##3Like bashrcContains the full path of the PowerShell profile for the current user and the current host application. You can use this variable to represent the profile in commands. For example, you can use it in a command to determine whether a profile has been created:
Contains the full path of the PowerShell profile for the current user and the current host application. 
You can use this variable to represent the profile in commands. 
For example, you can use it in a command to determine whether a profile has been created:

$null
$null is an automatic variable that contains a null or empty value. 
You can use this variable to represent an absent or undefined value in commands and scripts.


###Type Casting
$int="something"
$int.GetType().name == string

$int=4
$int.GetType().name == Int32

[string]$int= 42
$int.GetType().name == String

[string]$string = 'balloon'
[int]$string.GetType().name ### temporaily changes to int, then back again b/c cannot make a string an int

[int]6.5 = 6
[int]6.6 = 7
[float]6.6== 6.6
[double]6.4 == 6.4
[int]0xFF == 255, converts hex

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Arrays:
###set of multiple values that one can index through

Ways to make arrays:
$array=@()  
$number_arr= 4, 5,6
[array]$blank_array=""    ###$blank_array.count will equal 1, thus not exactly empty, throws off indexes

$number.arr.Getype().basetype.name ### check if it is an array   ###$array -is [array]   another way for checking if a variable is an array( can be used for int, float, etc...)
if ($array.count -eq 0) { write-host "empty like my mind"}   ### compares to see if array is empty

$poly_arr = (Get-ComputerInfo), "help me", 6472   ### can have strings, numbers, and cmdlets
$poly_arr[1] ### reference element in array by index
$poly_arr | Select-Object -Index 2 ### also like the above

$seq_nums= 4..50  ###iterates through 1-50
$seq_nums[-1], ### refernces the last element ### [-1..-5], [1,2,3,4,5] etc...


###Nested Array
Normal/Traditional Array -> $array = 1, 2, 3
Nested/Jagged Array -> $nested=@, !, $array, # -> {@, !, {1, 2, 3}, #}
                                                    output:
                                                   @, $null, $null,
                                                   !, $null, $null,
                                                   1,      2,     3,
                                                   #, $null,$null,
 $nested[2]= 1, 2, 3
 $nested[2][1] = 2
 $nested[3][1] = $error   ### tried to grab null
 
 
 
 ###Multi-Dimensional -> $multi = tri, square, $nested, cir
 -> {tri, square, {@, ! {1, 2, 3}, #},cir}
 output:
 tri, $null
 square,
 @     , !, 1, #            ### fills the empty spaces with '$null'
            2,
            3,
 cir
 
 $multi[2]= @, !, {1, 2, 3}, #
 $multi[2][2]= 1,2 ,3
 $multi[2][2][1] = 2
 $multi[1][2][3] = $error
      

-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Hash Table:
 
$hashy=@{key="value" ; key2="value2" ; } #manually creates a hash table

$another=@{}        ###empty hash table
$another.Ayy_Lmao = "yes"       ###adds to hash table
$another["AYYY"] = "lmao"   ###same as above
$another.Add("Kannneeeda","Tetsuuuoooo")      ###same as above

$ordered = [ordered]@{}
$ordered."McDonalds" = @("BigMac", "1 Chiccy Nuggy", "Caramel Frappe", "2 Lg Fries")
        ### Name = McDonalds ; Value = "BigMac......."
$ordered["Chik-fila-A"]="Salad"
$ordered.Add("Taco Bell", "shits")
$ordered."Chik-fila-A"    -OR- $ordered.["chik-fila-A"]       ### calls the value for the key/name

$orderd.keys/.values    ### shows said item
$ordered["Taco Bell", "McDonalds"]   ### gets values for two keys

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
PIPELINES!!!!:

##### works for any cmdlet
get-service | format-table *   
get-service | format-list *   
get-service | get-memeber     ### gives methods and properties of get-service
get-member -InputObject get-service     ###gives methods specific for get-service
get-Service bfe | get-Member     ### gives methods/property for 'bfe'
(Get-Service bfe).StartType       ### shows startype, i.e 'automatic'
(get-service bfe).stop()          ### stops a service
Get-Service | sort-object -property status    ###orders stopped/running
Get-Service | group-object -property status     ###groups number of stopped/running
Get-Service | Sort-Object status,name     ###sorts of status, then name in alpha

Get-Service | Where-Object {$_.status -eq "Running"}      ###gives only running services
ps | where-object {$_.Name -notlike 'powershell*' } | Sort-Object id -Descending
ps | select-object -first 10
ps svchost | Select-Object -ExpandProperty handles

gci | Measure-Object length
gci | Measure-Object length -Average -Maximum -Minimum -sum





'1', '7', '10', '8', '2', '3' | Sort-Object   ###sorts in ascii order
'1', '7', '10', '8', '2', '3' | Sort-Object -Property {[int]$_}     ###sorts as integers
1..10 | sort-object -Property {Get-Random}      ###sorts in random order


###write-host sensd to screen, cant pipeline 
###write-output puts it through pipeline 


Get-Command -Verb format ###gives methods of formating
###format-wide/table/list/custom
I.E. get-service| format-table name, status


$cols = @{Label='KB'; Expression = { [ int]($_.Length/1KB) }}
gci | format-table name, $cols
 
 
 
 gci | Sort-Object -Property Extension | Format-Table -GroupBy Extension

###Compares between two different outputs
PS C:\Users\student\Documents\PowerShell Stuff> "ayy lmao" > test.txt

PS C:\Users\student\Documents\PowerShell Stuff> $before = gci

PS C:\Users\student\Documents\PowerShell Stuff> '42' > test.txt

PS C:\Users\student\Documents\PowerShell Stuff> $after = gci
PS C:\Users\student\Documents\PowerShell Stuff> compare-object $before $after -Property Length, Name

Length Name     SideIndicator
------ ----     -------------
    10 test.txt =>           
    22 test.txt <=           







----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
ScriptBlock:
$mybloack = {get-service | format-table name, status}
The Pipeline Activity

    Display the start time of the earliest and latest running processes

    Identify a cmdlet that returns the current date and time then using this cmdlet and Select-object, display only the current day of the week

    Identify a cmdlet that displays a list of installed hotfixes.

    Extend the expression to sort the list by install date, and display only the install date and hotfix ID.

    Extend the expression further, but this time sort by description, include description, hotfix ID, and install Date.


& $myblock        #runs the scriptblock


alt:
$a = 1
$c = 1
$b = { 1 + 1 + $c }
$a += &$b














